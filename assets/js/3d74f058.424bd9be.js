"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[910],{3466:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>h});const l=JSON.parse('{"id":"utility","title":"Utility","description":"Aether provides different utility functions to help with usage of the library.","source":"@site/docs/utility.md","sourceDirName":".","slug":"/utility","permalink":"/aether/docs/utility","draft":false,"unlisted":false,"editUrl":"https://github.com/quamatic/aether/tree/main/website/docs/utility.md","tags":[],"version":"current","frontMatter":{"title":"Utility"},"sidebar":"aether","previous":{"title":"inline","permalink":"/aether/docs/middleware/inline"},"next":{"title":"Types","permalink":"/aether/docs/types"}}');var r=t(6106),c=t(2036),i=t(9269),s=t(8914);const a={title:"Utility"},o=void 0,d={},h=[{value:"<code>getPlacementPosition</code>",id:"getplacementposition",level:2},{value:"<code>getOppositePlacement</code>",id:"getoppositeplacement",level:2},{value:"<code>getOppositeAlignmentPlacement</code>",id:"getoppositealignmentplacement",level:2},{value:"<code>getExpandedPlacements</code>",id:"getexpandedplacements",level:2},{value:"<code>getOppositeAxisPlacements</code>",id:"getoppositeaxisplacements",level:2},{value:"<code>placement</code>",id:"placement",level:3},{value:"<code>flipAlignment</code>",id:"flipalignment",level:3},{value:"<code>direction</code>",id:"direction",level:3},{value:"<code>rtl</code>",id:"rtl",level:3},{value:"<code>Example</code>",id:"example",level:3},{value:"<code>getAlignmentSides</code>",id:"getalignmentsides",level:2},{value:"<code>placement</code>",id:"placement-1",level:3},{value:"<code>rects</code>",id:"rects",level:3},{value:"<code>rtl</code>",id:"rtl-1",level:3},{value:"<code>Example</code>",id:"example-1",level:3},{value:"<code>getElementBoundingRect</code>",id:"getelementboundingrect",level:2},{value:"<code>element</code>",id:"element",level:3},{value:"<code>includeScale</code>",id:"includescale",level:3},{value:"<code>offsetParent</code>",id:"offsetparent",level:3},{value:"<code>cache</code>",id:"cache",level:3},{value:"<code>getElementRects</code>",id:"getelementrects",level:2},{value:"<code>reference</code>",id:"reference",level:3},{value:"<code>target</code>",id:"target",level:3},{value:"<code>cache</code>",id:"cache-1",level:3},{value:"<code>getClippingRect</code>",id:"getclippingrect",level:2},{value:"<code>element</code>",id:"element-1",level:3},{value:"<code>boundary</code>",id:"boundary",level:3},{value:"<code>rootBoundary</code>",id:"rootboundary",level:3},{value:"<code>cache</code>",id:"cache-2",level:3},{value:"<code>getScale</code>",id:"getscale",level:2},{value:"<code>element</code>",id:"element-2",level:3},{value:"<code>cache</code>",id:"cache-3",level:3},{value:"<code>getOffsetParent</code>",id:"getoffsetparent",level:2},{value:"<code>element</code>",id:"element-3",level:3},{value:"<code>getLayerElement</code>",id:"getlayerelement",level:2},{value:"<code>element</code>",id:"element-4",level:3},{value:"<code>convertOffsetParentRectToRelativeRect</code>",id:"convertoffsetparentrecttorelativerect",level:2},{value:"<code>rect</code>",id:"rect",level:3},{value:"<code>offsetParent</code>",id:"offsetparent-1",level:3},{value:"<code>cache</code>",id:"cache-4",level:3},{value:"<code>isElement</code>",id:"iselement",level:2},{value:"<code>unwrapElement</code>",id:"unwrapelement",level:2},{value:"<code>convertRectToBoundingRect</code>",id:"convertrecttoboundingrect",level:2},{value:"<code>isSameRect</code>",id:"issamerect",level:2},{value:"<code>read</code>",id:"read",level:2},{value:"<code>getPaddingObject</code>",id:"getpaddingobject",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Aether provides different utility functions to help with usage of the library."}),"\n",(0,r.jsx)(n.h2,{id:"getplacementposition",children:(0,r.jsx)(n.code,{children:"getPlacementPosition"})}),"\n",(0,r.jsxs)(n.p,{children:["This is useful for when you have a value with a ",(0,r.jsx)(n.a,{href:"./types#placement",children:(0,r.jsx)(n.code,{children:"Placement"})})," type and need to extract\nthe side and/or the alignment."]}),"\n",(0,r.jsxs)(i.A,{groupId:"package-manager",children:[(0,r.jsx)(s.A,{value:"wally",label:"luau",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-luau",children:'local Aether = require(path.to.aether)\n\nlocal side, alignment = Aether.getPlacementPosition("top-start")\nprint(side, alignment) -- "top" "start"\n\nlocal side, alignment = Aether.getPlacementPosition("bottom")\nprint(side, alignment) -- "bottom" "nil"\n'})})}),(0,r.jsx)(s.A,{value:"roblox-ts",label:"roblox-ts",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { getPlacementPosition } from "@rbxts/aether";\n\nconst [side, alignment] = getPlacementPosition("top-start");\nprint(side, alignment); // "top" "start"\n\nconst [side, alignment] = getPlacementPosition("bottom");\nprint(side, alignment); // "bottom" "nil"\n'})})})]}),"\n",(0,r.jsx)(n.h2,{id:"getoppositeplacement",children:(0,r.jsx)(n.code,{children:"getOppositePlacement"})}),"\n",(0,r.jsxs)(n.p,{children:["Returns the opposite ",(0,r.jsx)(n.strong,{children:"side"})," part of a given placement."]}),"\n",(0,r.jsx)(n.p,{children:"The opposite sides are as follows:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"top"'})," - ",(0,r.jsx)(n.code,{children:'"bottom"'})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"bottom'}),'" - ',(0,r.jsx)(n.code,{children:'"top"'})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"left"'}),' - "',(0,r.jsx)(n.code,{children:'"right"'})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"right"'})," - ",(0,r.jsx)(n.code,{children:'"left"'})]}),"\n"]}),"\n",(0,r.jsxs)(i.A,{groupId:"package-manager",children:[(0,r.jsx)(s.A,{value:"wally",label:"luau",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-luau",children:'local Aether = require(path.to.aether)\n\nlocal placement = Aether.getOppositePlacement("top-start")\nprint(placement) -- "bottom-start"\n'})})}),(0,r.jsx)(s.A,{value:"roblox-ts",label:"roblox-ts",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { getOppositePlacement } from "@rbxts/aether";\n\nconst placement = getOppositePlacement("top-start");\nprint(placement); // "bottom-start"\n'})})})]}),"\n",(0,r.jsx)(n.h2,{id:"getoppositealignmentplacement",children:(0,r.jsx)(n.code,{children:"getOppositeAlignmentPlacement"})}),"\n",(0,r.jsxs)(n.p,{children:["Returns the opposite ",(0,r.jsx)(n.strong,{children:"alignment"})," part of a given placement."]}),"\n",(0,r.jsx)(n.p,{children:"The opposite alignments are as follows:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"start"'})," - ",(0,r.jsx)(n.code,{children:'"end"'})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"end"'})," - ",(0,r.jsx)(n.code,{children:'"start"'})]}),"\n"]}),"\n",(0,r.jsxs)(i.A,{groupId:"package-manager",children:[(0,r.jsx)(s.A,{value:"wally",label:"luau",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-luau",children:'local Aether = require(path.to.aether)\n\nlocal placement = Aether.getOppositeAlignmentPlacement("top-start")\nprint(placement) -- "top-end"\n'})})}),(0,r.jsx)(s.A,{value:"roblox-ts",label:"roblox-ts",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { getOppositeAlignmentPlacement } from "@rbxts/aether";\n\nconst placement = getOppositeAlignmentPlacement("top-start");\nprint(placement); // "top-end"\n'})})})]}),"\n",(0,r.jsx)(n.h2,{id:"getexpandedplacements",children:(0,r.jsx)(n.code,{children:"getExpandedPlacements"})}),"\n",(0,r.jsx)(n.p,{children:"Provides all possible alternative values for a given placement, excluding the initial placement itself."}),"\n",(0,r.jsxs)(i.A,{groupId:"package-manager",children:[(0,r.jsx)(s.A,{value:"wally",label:"luau",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-luau",children:'local Aether = require(path.to.aether)\n\nlocal placements = Aether.getExpandedPlacements("top-start")\nprint(placements) -- "{ "top-end", "bottom-start", "bottom-end" }"\n'})})}),(0,r.jsx)(s.A,{value:"roblox-ts",label:"roblox-ts",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { getExpandedPlacements } from "@rbxts/aether";\n\nconst placement = getExpandedPlacements("top-start");\nprint(placement); // "{ "top-end", "bottom-start", "bottom-end" }"\n'})})})]}),"\n",(0,r.jsx)(n.h2,{id:"getoppositeaxisplacements",children:(0,r.jsx)(n.code,{children:"getOppositeAxisPlacements"})}),"\n",(0,r.jsx)(n.p,{children:"Returns all of the possible placements from the opposite axis of a given placement."}),"\n",(0,r.jsx)(n.p,{children:"The following parameters can be passed:"}),"\n",(0,r.jsx)(n.h3,{id:"placement",children:(0,r.jsx)(n.code,{children:"placement"})}),"\n",(0,r.jsx)(n.p,{children:"The placement to extract from."}),"\n",(0,r.jsx)(n.h3,{id:"flipalignment",children:(0,r.jsx)(n.code,{children:"flipAlignment"})}),"\n",(0,r.jsxs)(n.p,{children:["When the given ",(0,r.jsx)(n.code,{children:"placement"})," has an alignment and this is set to ",(0,r.jsx)(n.code,{children:"true"}),", the returned placements will include the opposite\nalignment placements as well."]}),"\n",(0,r.jsx)(n.h3,{id:"direction",children:(0,r.jsx)(n.code,{children:"direction"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"./types#alignment",children:"alignment"})," to start from. This affects the order of placements."]}),"\n",(0,r.jsxs)(n.p,{children:["For example, when the ",(0,r.jsx)(n.a,{href:"./types#side",children:(0,r.jsx)(n.code,{children:"side"})})," of the placement is set to ",(0,r.jsx)(n.code,{children:"top"})," or ",(0,r.jsx)(n.code,{children:"bottom"}),", and the direction is set to ",(0,r.jsx)(n.code,{children:"start"}),", the opposite side order becomes ",(0,r.jsx)(n.code,{children:"[left, right]"}),". Conversely, a direction of end or none results in ",(0,r.jsx)(n.code,{children:"[right, left]"}),"."]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.code,{children:"rtl"})," is set to ",(0,r.jsx)(n.code,{children:"true"}),", the resulting value is flipped to the opposite end of its usual direction."]})}),"\n",(0,r.jsx)(n.h3,{id:"rtl",children:(0,r.jsx)(n.code,{children:"rtl"})}),"\n",(0,r.jsxs)(n.p,{children:["When set to ",(0,r.jsx)(n.code,{children:"true"}),", right-to-left calculations will be used instead."]}),"\n",(0,r.jsx)(n.h3,{id:"example",children:(0,r.jsx)(n.code,{children:"Example"})}),"\n",(0,r.jsxs)(i.A,{groupId:"package-manager",children:[(0,r.jsx)(s.A,{value:"wally",label:"luau",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-luau",children:'local Aether = require(path.to.aether)\n\nlocal placements = Aether.getOppositeAxisPlacements("top-start", true, "start")\n\n-- Since flipAlignment is `true`, we have an extra two values that are both opposite alignments.\n-- The direction is also "start", so the order is [left, right].\n\nprint(placements) -- { "left-start", "bottom-start", "left-end", "bottom-end" }\n'})})}),(0,r.jsx)(s.A,{value:"roblox-ts",label:"roblox-ts",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { getOppositeAxisPlacements } from "@rbxts/aether";\n\nconst placement = getOppositeAxisPlacements("top-start", true, "start");\n\n// Since flipAlignment is `true`, we have an extra two values that are both opposite alignments.\n// The direction is also "start", so the order is [left, right].\n\nprint(placement); // "{ "left-start", "left-end", "bottom-start", "bottom-end" }"\n'})})})]}),"\n",(0,r.jsx)(n.h2,{id:"getalignmentsides",children:(0,r.jsx)(n.code,{children:"getAlignmentSides"})}),"\n",(0,r.jsxs)(n.p,{children:["Returns the two possible ",(0,r.jsx)(n.a,{href:"./types#side",children:(0,r.jsx)(n.code,{children:"sides"})})," of a given placement, listed in order as the main side followed by the cross (opposite) side."]}),"\n",(0,r.jsx)(n.p,{children:"The following parameters can be passed:"}),"\n",(0,r.jsx)(n.h3,{id:"placement-1",children:(0,r.jsx)(n.code,{children:"placement"})}),"\n",(0,r.jsx)(n.p,{children:"The placement to extract from."}),"\n",(0,r.jsx)(n.h3,{id:"rects",children:(0,r.jsx)(n.code,{children:"rects"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"./types#elementrects",children:(0,r.jsx)(n.code,{children:"element rects"})})," to use. Typically, this will be the ",(0,r.jsx)(n.a,{href:"./middleware#rects",children:(0,r.jsx)(n.code,{children:"rects"})})," value provided by middleware."]}),"\n",(0,r.jsx)(n.h3,{id:"rtl-1",children:(0,r.jsx)(n.code,{children:"rtl"})}),"\n",(0,r.jsxs)(n.p,{children:["Default value: ",(0,r.jsx)(n.code,{children:"false"})]}),"\n",(0,r.jsxs)(n.p,{children:["When set to ",(0,r.jsx)(n.code,{children:"true"}),", right-to-left calculations will be used instead."]}),"\n",(0,r.jsx)(n.h3,{id:"example-1",children:(0,r.jsx)(n.code,{children:"Example"})}),"\n",(0,r.jsxs)(i.A,{groupId:"package-manager",children:[(0,r.jsx)(s.A,{value:"wally",label:"luau",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-luau",children:'local Aether = require(path.to.aether)\n\n-- Lets say "rects" is derived from `state.rects` via middleware.\nlocal main, cross = Aether.getAlignmentSides("top-start", rects)\n\nprint(main, cross) -- - "bottom", "top";\n'})})}),(0,r.jsx)(s.A,{value:"roblox-ts",label:"roblox-ts",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { getOppositeAxisPlacements } from "@rbxts/aether";\n\n// Lets say "rects" is derived from `state.rects` via middleware.\nconst [main, cross] = getAlignmentSides("top-start", rects);\n\nprint(main, cross); // - "bottom", "top";\n'})})})]}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsxs)(n.p,{children:["The length (dimension) of the elements provided via ",(0,r.jsx)(n.code,{children:"rects"})," is considered during the process, based on the axis variant of the given placement's alignment."]}),(0,r.jsxs)(n.p,{children:["If the ",(0,r.jsx)(n.code,{children:"reference"})," element's length exceeds that of the ",(0,r.jsx)(n.code,{children:"target"})," element, the main side is flipped to its opposite direction, making the cross side its counterpart."]})]}),"\n",(0,r.jsx)(n.h2,{id:"getelementboundingrect",children:(0,r.jsx)(n.code,{children:"getElementBoundingRect"})}),"\n",(0,r.jsxs)(n.p,{children:["Returns the ",(0,r.jsx)(n.a,{href:"./types#boundingrect",children:"BoundingRect"})," of a given element, with extra calculations to get the precise area."]}),"\n",(0,r.jsx)(n.p,{children:"The following parameters can be passed:"}),"\n",(0,r.jsx)(n.h3,{id:"element",children:(0,r.jsx)(n.code,{children:"element"})}),"\n",(0,r.jsxs)(n.p,{children:["The element to calculate the rect for. This can be a ",(0,r.jsx)(n.a,{href:"./guides/virtual-elements",children:"virtual element"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"includescale",children:(0,r.jsx)(n.code,{children:"includeScale"})}),"\n",(0,r.jsxs)(n.p,{children:["When set to ",(0,r.jsx)(n.code,{children:"true"}),", the ancestor ",(0,r.jsx)(n.code,{children:"UIScale"}),"'s will be accounted for in the calculation. I.e., values will be scaled down based on the final factor."]}),"\n",(0,r.jsx)(n.h3,{id:"offsetparent",children:(0,r.jsx)(n.code,{children:"offsetParent"})}),"\n",(0,r.jsxs)(n.p,{children:["The element to calculate relative to. When ",(0,r.jsx)(n.code,{children:"includeScale"})," is set to ",(0,r.jsx)(n.code,{children:"true"}),", the ancestor ",(0,r.jsx)(n.code,{children:"UIScale"}),"'s of this element will be considered instead of the given ",(0,r.jsx)(n.code,{children:"element"}),". Note that ",(0,r.jsx)(n.code,{children:"offsetParent"})," is typically just the ",(0,r.jsx)(n.code,{children:"Parent"})," property of the element, and it also doesn't have to necessarily be accessed off of ",(0,r.jsx)(n.code,{children:"element"})," itself."]}),"\n",(0,r.jsx)(n.h3,{id:"cache",children:(0,r.jsx)(n.code,{children:"cache"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"./guides/processing#cache",children:"lifecycle cache"})]}),"\n",(0,r.jsx)(n.h2,{id:"getelementrects",children:(0,r.jsx)(n.code,{children:"getElementRects"})}),"\n",(0,r.jsxs)(n.p,{children:["Takes in the ",(0,r.jsx)(n.code,{children:"elements"})," and returns the element ",(0,r.jsx)(n.a,{href:"./types#rect",children:(0,r.jsx)(n.code,{children:"Rect"})})," objects."]}),"\n",(0,r.jsx)(n.p,{children:"The following parameters can be passed:"}),"\n",(0,r.jsx)(n.h3,{id:"reference",children:(0,r.jsx)(n.code,{children:"reference"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"x"})," and ",(0,r.jsx)(n.code,{children:"y"})," values of a ",(0,r.jsx)(n.code,{children:"reference"})," ",(0,r.jsx)(n.code,{children:"Rect"})," should be its coordinates relative to the floating element\u2019s ",(0,r.jsx)(n.code,{children:"Parent"})," element if required rather than the screen."]}),"\n",(0,r.jsx)(n.h3,{id:"target",children:(0,r.jsx)(n.code,{children:"target"})}),"\n",(0,r.jsxs)(n.p,{children:["Both ",(0,r.jsx)(n.code,{children:"x"})," and ",(0,r.jsx)(n.code,{children:"y"})," are not relevant initially, so you can set these both of these to ",(0,r.jsx)(n.code,{children:"0"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"cache-1",children:(0,r.jsx)(n.code,{children:"cache"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"./guides/processing#cache",children:"lifecycle cache"})]}),"\n",(0,r.jsx)(n.h2,{id:"getclippingrect",children:(0,r.jsx)(n.code,{children:"getClippingRect"})}),"\n",(0,r.jsxs)(n.p,{children:["Returns the Rect (",(0,r.jsx)(n.strong,{children:"relative to the screen"}),") whose outside bounds will clip the given element. For instance, the screen itself."]}),"\n",(0,r.jsx)(n.p,{children:"The following parameters can be passed:"}),"\n",(0,r.jsx)(n.h3,{id:"element-1",children:(0,r.jsx)(n.code,{children:"element"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"GuiObject"})," to calculate the clipping rect for."]}),"\n",(0,r.jsx)(n.h3,{id:"boundary",children:(0,r.jsx)(n.code,{children:"boundary"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"/aether/docs/guides/collisions#boundary",children:"boundary"})," to use."]}),"\n",(0,r.jsx)(n.h3,{id:"rootboundary",children:(0,r.jsx)(n.code,{children:"rootBoundary"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"./guides/collisions#rootboundary",children:"root boundary"})," to use."]}),"\n",(0,r.jsx)(n.h3,{id:"cache-2",children:(0,r.jsx)(n.code,{children:"cache"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"./guides/processing#cache",children:"lifecycle cache"})]}),"\n",(0,r.jsx)(n.h2,{id:"getscale",children:(0,r.jsx)(n.code,{children:"getScale"})}),"\n",(0,r.jsx)(n.p,{children:"Returns the scale of the given element."}),"\n",(0,r.jsxs)(n.p,{children:["The scale of an element is the factor of each ancestor ",(0,r.jsx)(n.code,{children:"UIScale"})," that affects it."]}),"\n",(0,r.jsx)(n.h3,{id:"element-2",children:(0,r.jsx)(n.code,{children:"element"})}),"\n",(0,r.jsx)(n.p,{children:"The element to check"}),"\n",(0,r.jsx)(n.h3,{id:"cache-3",children:(0,r.jsx)(n.code,{children:"cache"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"./guides/processing#cache",children:"lifecycle cache"})]}),"\n",(0,r.jsx)(n.h2,{id:"getoffsetparent",children:(0,r.jsx)(n.code,{children:"getOffsetParent"})}),"\n",(0,r.jsx)(n.p,{children:'Returns the "offset" parent of the given element.'}),"\n",(0,r.jsxs)(n.p,{children:['The "offset" parent is the first valid parent of the given element. Most of the time,this is just the ',(0,r.jsx)(n.code,{children:"Parent"})," value, but there are cases where a ",(0,r.jsx)(n.code,{children:"Folder"})," instance may be used. Because of that, this is useful for being safe."]}),"\n",(0,r.jsx)(n.h3,{id:"element-3",children:(0,r.jsx)(n.code,{children:"element"})}),"\n",(0,r.jsx)(n.p,{children:"The element to get the parent from."}),"\n",(0,r.jsx)(n.h2,{id:"getlayerelement",children:(0,r.jsx)(n.code,{children:"getLayerElement"})}),"\n",(0,r.jsxs)(n.p,{children:["Returns the contaning ",(0,r.jsx)(n.code,{children:"LayerCollector"})," instance of the given element, if one exists."]}),"\n",(0,r.jsx)(n.h3,{id:"element-4",children:(0,r.jsx)(n.code,{children:"element"})}),"\n",(0,r.jsx)(n.p,{children:"The element to retrieve from."}),"\n",(0,r.jsx)(n.h2,{id:"convertoffsetparentrecttorelativerect",children:(0,r.jsx)(n.code,{children:"convertOffsetParentRectToRelativeRect"})}),"\n",(0,r.jsx)(n.p,{children:"Converts the given rect into a rect that is relative to that of the given offset parent."}),"\n",(0,r.jsx)(n.h3,{id:"rect",children:(0,r.jsx)(n.code,{children:"rect"})}),"\n",(0,r.jsx)(n.p,{children:"The rect to go off of."}),"\n",(0,r.jsx)(n.h3,{id:"offsetparent-1",children:(0,r.jsx)(n.code,{children:"offsetParent"})}),"\n",(0,r.jsx)(n.p,{children:"The offset parent element."}),"\n",(0,r.jsx)(n.h3,{id:"cache-4",children:(0,r.jsx)(n.code,{children:"cache"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"./guides/processing#cache",children:"lifecycle cache"})]}),"\n",(0,r.jsx)(n.h2,{id:"iselement",children:(0,r.jsx)(n.code,{children:"isElement"})}),"\n",(0,r.jsxs)(n.p,{children:["Determines if the passed value is a ",(0,r.jsx)(n.code,{children:"GuiObject"}),"."]}),"\n",(0,r.jsxs)(i.A,{groupId:"package-manager",children:[(0,r.jsx)(s.A,{value:"wally",label:"luau",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-luau",children:'local Aether = require(path.to.aether)\n\nlocal reference = Instance.new("Frame")\n\nprint(Aether.isElement(reference)) -- true\n'})})}),(0,r.jsx)(s.A,{value:"roblox-ts",label:"roblox-ts",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { isElement } from "@rbxts/aether";\n\nconst reference = new Instance("Frame");\n\nprint(isElement(reference)); // true\n'})})})]}),"\n",(0,r.jsx)(n.h2,{id:"unwrapelement",children:(0,r.jsx)(n.code,{children:"unwrapElement"})}),"\n",(0,r.jsxs)(n.p,{children:["Used for unwrapping an element into its ",(0,r.jsx)(n.code,{children:"GuiObject"})," form, if viable. For example, extracting the ",(0,r.jsx)(n.code,{children:"contextElement"})," from a ",(0,r.jsx)(n.a,{href:"./guides/virtual-elements#contextelement",children:"virtual element"})," when present."]}),"\n",(0,r.jsxs)(n.p,{children:["If the element is already a ",(0,r.jsx)(n.code,{children:"GuiObject"})," then that will be returned."]}),"\n",(0,r.jsxs)(i.A,{groupId:"package-manager",children:[(0,r.jsx)(s.A,{value:"wally",label:"luau",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-luau",children:'local Aether = require(path.to.aether)\n\nlocal reference = Instance.new("Frame")\n\nprint(Aether.unwrapElement(reference)) -- Frame\n\nlocal contextElement = Instance.new("TextLabel")\nlocal reference: Aether.VirtualElement = {\n    getBoundingRect = function()\n        return ...\n    end,\n\n    contextElement = contextElement,\n}\n\nprint(Aether.unwrapElement(reference)) -- TextLabel\n'})})}),(0,r.jsx)(s.A,{value:"roblox-ts",label:"roblox-ts",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { unwrapElement, type VirtualElement } from "@rbxts/aether";\n\nconst reference = new Instance("Frame");\n\nprint(unwrapElement(reference)); // Frame\n\nconst contextElement = new Instance("TextLabel");\nconst reference: VirtualElement = {\n    getBoundingRect: () => {\n        return ...\n    },\n\n    contextElement,\n};\n\nprint(unwrapElement(reference)); // TextLabel\n'})})})]}),"\n",(0,r.jsx)(n.h2,{id:"convertrecttoboundingrect",children:(0,r.jsx)(n.code,{children:"convertRectToBoundingRect"})}),"\n",(0,r.jsxs)(n.p,{children:["Converts a ",(0,r.jsx)(n.a,{href:"./types#rect",children:"Rect"})," into its ",(0,r.jsx)(n.a,{href:"./types#boundingrect",children:"BoundingRect"})," form."]}),"\n",(0,r.jsxs)(i.A,{groupId:"package-manager",children:[(0,r.jsx)(s.A,{value:"wally",label:"luau",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-luau",children:"local Aether = require(path.to.aether)\n\nlocal rect: Aether.Rect = {\n    x = 5,\n    y = 10,\n    width = 15,\n    height = 20,\n}\n\nlocal result = Aether.convertRectToBoundingRect(rect)\n\n--[[\n    Resulting BoundingRect:\n\n    x: 5,\n    y: 10,\n    width: 15,\n    height: 15,\n    left: 5,\n    top: 10,\n    left: 5,\n    right: 20,\n    bottom: 30,\n]]\n"})})}),(0,r.jsx)(s.A,{value:"roblox-ts",label:"roblox-ts",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { convertRectToBoundingRect, type Rect } from "@rbxts/aether";\n\nconst rect: Rect = {\n    x: 5,\n    y: 10,\n    width: 15,\n    height: 20,\n}\n\nconst result = convertRectToBoundingRect(rect);\n\n/**\n  * Resulting BoundingRect:\n  *\n  * x: 5,\n  * y: 10,\n  * width: 15,\n  * height: 15,\n  * left: 5,\n  * top: 10,\n  * left: 5,\n  * right: 20,\n  * bottom: 30,\n  */\n'})})})]}),"\n",(0,r.jsx)(n.h2,{id:"issamerect",children:(0,r.jsx)(n.code,{children:"isSameRect"})}),"\n",(0,r.jsxs)(n.p,{children:["Returns ",(0,r.jsx)(n.code,{children:"true"})," if two ",(0,r.jsx)(n.a,{href:"./types#rect",children:"Rect"})," objects are the same (i.e., the same values)."]}),"\n",(0,r.jsxs)(i.A,{groupId:"package-manager",children:[(0,r.jsx)(s.A,{value:"wally",label:"luau",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-luau",children:'local Aether = require(path.to.aether)\n\nlocal one: Aether.Rect = {\n    x = 0,\n    y = 0,\n    width = 0,\n    height = 0,\n}\n\nlocal two: Aether.Rect = {\n    x = 0,\n    y = 0,\n    width = 10,\n    height = 10,\n}\n\nprint(isSameRect(one, one)) -- "true"\nprint(isSameRect(one, two)) -- "false"\n'})})}),(0,r.jsx)(s.A,{value:"roblox-ts",label:"roblox-ts",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { isSameRect, type Rect } from "@rbxts/aether";\n\nconst one: Rect = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n};\n\nconst two: Rect = {\n    x: 0,\n    y: 0,\n    width: 10,\n    height: 10,\n};\n\nprint(isSameRect(one, one)); // "true"\nprint(isSameRect(one, two)); // "false"\n'})})})]}),"\n",(0,r.jsx)(n.h2,{id:"read",children:(0,r.jsx)(n.code,{children:"read"})}),"\n",(0,r.jsxs)(n.p,{children:["Allows you to evaluate middleware input when it is derivable, being able to take advantage of passing the ",(0,r.jsx)(n.a,{href:"./middleware#middleware-state",children:"lifecycle"}),"."]}),"\n",(0,r.jsxs)(i.A,{groupId:"package-manager",children:[(0,r.jsx)(s.A,{value:"wally",label:"luau",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-luau",children:'local Aether = require(path.to.aether)\n\nlocal function middleware(input: Aether.Derivable<number>): Aether.Middleware\n    return {\n        name = "middleware",\n        run = function(state)\n            local value = Aether.read(input, state)\n            -- ...\n        end\n    }\nend\n'})})}),(0,r.jsx)(s.A,{value:"roblox-ts",label:"roblox-ts",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { read, type Middleware, type Derivable } from "@rbxts/aether";\n\nfunction middleware(input: Derivable<number>): Middleware {\n    return {\n        name: "middleware",\n        run: (state) => {\n            const value = read(input, state);\n            // ...\n        }\n    }\n}\n'})})})]}),"\n",(0,r.jsx)(n.h2,{id:"getpaddingobject",children:(0,r.jsx)(n.code,{children:"getPaddingObject"})}),"\n",(0,r.jsxs)(n.p,{children:["This is used for converting a ",(0,r.jsx)(n.a,{href:"./types#padding",children:"Padding"})," value into a usable ",(0,r.jsx)(n.a,{href:"./types#sideobject",children:"SideObject"}),"."]}),"\n",(0,r.jsxs)(i.A,{groupId:"package-manager",children:[(0,r.jsx)(s.A,{value:"wally",label:"luau",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-luau",children:"local Aether = require(path.to.aether)\n\nlocal padding = Aether.getPaddingObject(5)\n\n--[[\n    The padding value will be:\n\n    top: 5,\n    bottom: 5,\n    left: 5,\n    right: 5,\n]]\n\nlocal padding = Aether.getPaddingObject({\n    top = 5,\n    bottom = 5,\n})\n\n--[[\n    The padding value will be:\n\n    top: 5,\n    bottom: 5,\n    left: 0,\n    right: 0,\n]]\n"})})}),(0,r.jsx)(s.A,{value:"roblox-ts",label:"roblox-ts",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { getPaddingObject } from "@rbxts/aether";\n\nconst padding = getPaddingObject(5);\n\n/**\n * The padding value will be:\n *\n * top: 5,\n * bottom: 5,\n * left: 5,\n * right: 5,\n */\n\nconst padding = getPaddingObject({\n    top: 5,\n    bottom: 5,\n});\n\n/**\n * The padding value will be:\n *\n * top: 5,\n * bottom: 5,\n * left: 0,\n * right: 0,\n */\n'})})})]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["When providing a ",(0,r.jsx)(n.code,{children:"SideObject"})," value, any omitted sides are automatically evaluated as ",(0,r.jsx)(n.code,{children:"0"}),"."]})})]})}function p(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8914:(e,n,t)=>{t.d(n,{A:()=>i});t(7378);var l=t(3372);const r={tabItem:"tabItem_FS4i"};var c=t(6106);function i(e){let{children:n,hidden:t,className:i}=e;return(0,c.jsx)("div",{role:"tabpanel",className:(0,l.A)(r.tabItem,i),hidden:t,children:n})}},9269:(e,n,t)=>{t.d(n,{A:()=>w});var l=t(7378),r=t(3372),c=t(2703),i=t(505),s=t(5086),a=t(6656),o=t(2097),d=t(421);function h(e){return l.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,l.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:n,children:t}=e;return(0,l.useMemo)((()=>{const e=n??function(e){return h(e).map((e=>{let{props:{value:n,label:t,attributes:l,default:r}}=e;return{value:n,label:t,attributes:l,default:r}}))}(t);return function(e){const n=(0,o.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function x(e){let{queryString:n=!1,groupId:t}=e;const r=(0,i.W6)(),c=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,a.aZ)(c),(0,l.useCallback)((e=>{if(!c)return;const n=new URLSearchParams(r.location.search);n.set(c,e),r.replace({...r.location,search:n.toString()})}),[c,r])]}function m(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,c=u(e),[i,a]=(0,l.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const l=t.find((e=>e.default))??t[0];if(!l)throw new Error("Unexpected error: 0 tabValues");return l.value}({defaultValue:n,tabValues:c}))),[o,h]=x({queryString:t,groupId:r}),[m,j]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,c]=(0,d.Dv)(t);return[r,(0,l.useCallback)((e=>{t&&c.set(e)}),[t,c])]}({groupId:r}),g=(()=>{const e=o??m;return p({value:e,tabValues:c})?e:null})();(0,s.A)((()=>{g&&a(g)}),[g]);return{selectedValue:i,selectValue:(0,l.useCallback)((e=>{if(!p({value:e,tabValues:c}))throw new Error(`Can't select invalid tab value=${e}`);a(e),h(e),j(e)}),[h,j,c]),tabValues:c}}var j=t(7606);const g={tabList:"tabList_scTV",tabItem:"tabItem_tmPb"};var f=t(6106);function v(e){let{className:n,block:t,selectedValue:l,selectValue:i,tabValues:s}=e;const a=[],{blockElementScrollPositionUntilNextRender:o}=(0,c.a_)(),d=e=>{const n=e.currentTarget,t=a.indexOf(n),r=s[t].value;r!==l&&(o(n),i(r))},h=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=a.indexOf(e.currentTarget)+1;n=a[t]??a[0];break}case"ArrowLeft":{const t=a.indexOf(e.currentTarget)-1;n=a[t]??a[a.length-1];break}}n?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:s.map((e=>{let{value:n,label:t,attributes:c}=e;return(0,f.jsx)("li",{role:"tab",tabIndex:l===n?0:-1,"aria-selected":l===n,ref:e=>a.push(e),onKeyDown:h,onClick:d,...c,className:(0,r.A)("tabs__item",g.tabItem,c?.className,{"tabs__item--active":l===n}),children:t??n},n)}))})}function b(e){let{lazy:n,children:t,selectedValue:c}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===c));return e?(0,l.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,l.cloneElement)(e,{key:n,hidden:e.props.value!==c})))})}function y(e){const n=m(e);return(0,f.jsxs)("div",{className:(0,r.A)("tabs-container",g.tabList),children:[(0,f.jsx)(v,{...n,...e}),(0,f.jsx)(b,{...n,...e})]})}function w(e){const n=(0,j.A)();return(0,f.jsx)(y,{...e,children:h(e.children)},String(n))}},2036:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>s});var l=t(7378);const r={},c=l.createContext(r);function i(e){const n=l.useContext(c);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),l.createElement(c.Provider,{value:n},e.children)}}}]);